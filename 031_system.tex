% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Система бенчмарков}

Бенчмарков в репозитории проекта \verb|tokio| не пригодны для анализа производительности в рамках данной работы, так как используют методы синхронизации имеющие не тривиальный эффект на результатах экспериментов:

\begin{itemize}
    \item Атомарное чтение и запись из множества исполняемых разными потоками задач скорее позволяет измерять производительность системы памяти физической машины, нежели взаимодействия структур рантайма~\cite{atomicOnModerHardware}.
    \item Ожидание исполнения в методе \verb|block_on| \verb|tokio| рантайма чревато неточным измерением из-за текущей реализации\footnote{\href{https://github.com/bheisler/criterion.rs/issues/819}{Проблема} измерения производительности асинхронных функций (Дата обращения: 4.1.2025)}.
\end{itemize}

Поэтому в качестве системы бенчмарков был создан проект \verb|tokiobench|\footnote{\href{https://github.com/IgorErin/tokiobench}{Репозиторий} проект tokiobench (Дата обращения: 4.1.2025)}, где предполагалось реализовать сценарии использования проекта \verb|tokio| в \verb|TATLIN.BACKUP|. При общении с командой \verb|TATLIN.BACKUP| был выделен основной сценарий:

\begin{figure}[H]
    \begin{center}
        \makebox[\textwidth]{\includegraphics[scale=0.55]{pictures/scenario.drawio.png}}
    \end{center}

    \caption{Упрощенное представление многопоточного рантайма.}
    \label{fig:tokio:duplicated_arch}
\end{figure}

\begin{itemize}
    \item Актор --- замыкания, в цикле ожидающие асинхронные события.
    \item Производитель --- замыкания, отправляющее на исполнение множество замыканий акторов.
\end{itemize}

Необходимо было исследовать производительность такого бенчмарка при следующих параметрах:

\begin{itemize}
    \item Тысяча листовых замыканий акторов.
    \item Тысяча итераций исполнения акторов.
    \item Сто замыканий производителей.
\end{itemize}

\subsection{Реализация бенчмарков}

Методы реализации бенчмарков из \verb|tokio| были улучшены:

\begin{itemize}
    \item Атомарные переменная была заменена иерархией заранее аллоцированных переиспользуемых от итерации к итерации буферами, коллекционирующими структры типа \verb|JoinHandle| задач.
    \item Ожидание структур типа \verb|JoinHandle| перенесено в отдельную задачу, которая сообщает о завершении обработки с помощью блокирующего канала.
\end{itemize}

Накладные расходы, вызванные использованием блокирующего канала были приняты во внимание, поэтому, исключительно для проверки, была создана реализация использующая спинлок: фиксирующий исполнение и сигнализирующий поток пишет значение в атомарную переменную --- поток бенчмарка ожидает этого в цикле.

\subsection{Реализация сценария}

Для эмуляции операций ввода вывода был использован метод \verb|yield_now()|: каждый актор тысячу раз выполнял \verb|yield_now|, заставляло исполнителя сохранять структуру типа \verb|Waker| в локальной коллекции, для последующего вызова метода \verb|wake()|. Вызов метода \verb|wake()| приводит при достаточном количестве сохраненных структура типа \verb|Waker| приводит к переполнению локальной очереди исполнителя, вынуждая последнего перемещать задачи из локальной очереди в глобальную. После выполнения исполнения задач из локальных очередей исполнители начинают обращаться к глобальной очереди, затем похищают задачи друг у друга. Такая реализация заставляет исполнителей беспрестанно взаимодействовать.

Константы были окружены непрозрачной для компилятора функцией, чтобы избежать нереалистичных оптимизаций.
