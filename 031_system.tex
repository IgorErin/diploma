% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Система бенчмарков}

В качестве системы бенчмарков был создан проект \verb|tokiobench|\footnote{\href{https://github.com/IgorErin/tokiobench}{Репозиторий} проект tokiobench (Дата обращения: 4.1.2025)}, где предполагалось реализовать автоматизированные сценарии бенчмарков, сбор метрик и визуализацию полученных данных в виде графиков.

\subsection{Поиск сценариев}

В условиях недоступности кода \verb|TATLIN.BACKUP| поиск интересных с точки зрения производительности сценариев по взаимодействию с глобальной очередью был начат с репозитория проекта \verb|tokio|.

Среди приведенных там сценариев был выделен один, представленный на листинге \ref{listing:bench:tokio:remote}.

\begin{listing}[H]
    \begin{minted}{rust}
for _ in 0..NUM_SPAWN {
    handles.push(rt.spawn(async {}));
}
rt.block_on(async {
    for handle in handles.drain(..) {
        handle.await.unwrap();
    }
});
    \end{minted}

    \caption{Tokio context spawning benchmark}
    \label{listing:bench:tokio:remote}
\end{listing}

А именно, задачи, в виде пустых асинхронных замыканий, спавнятся в главном потоке, их хендлеры коллекционируются, после чего рантайм поочередно ожидает исполнения задач используя метод \verb|block_on|.

В ходе общения с инженерами из \verb|TATLIN.BACKUP| был выделен сценарий их приложения: там присутствуют задачи, далее именуемые спавнерами, которые создают множество простых задач, далее именуемых листовыми задачами. Причем количество спавнеров и листовых задач варьируется.

\subsection{Проблема синхронизации}

Измерение производительности в данном случае предполагает измерение пропускной способности рантайма, что подразумевает измерение времени необходимое этому рантайму для исполнения фиксированного количества задач. Однако, для этого необходимо определить, когда все задачи были исполнены. Публичный интерфейс \verb|tokio| не позволяет получить информацию об этом, так как число необходимых к исполнению задач известно лишь пользователю. То есть нужно иметь какую-то синхронизацию, блокировать поток бенчмарка в ожидании конца обработки специфицированных рантайму задач. В бенчмарках \verb|tokio| делают это следующими способами:

\begin{itemize}
    \item Коллекционирует хендлеры, как представлено на листинге \ref{listing:bench:tokio:remote} и последовательно ожидают их в цикле с помощью метода \verb|block_on|
    \item Создают атомарную переменную с значением равным количеству задач и в каждой листовой задаче уменьшают ее значение на единицу. Задача, которая получила ноль в результате операции атомарного декремента, посылает сигнал с помощью блокирующего канала в главный поток, тем самым разблокирует его, как представлено на листинге \ref{listing:bench:tokio:atom}
\end{itemize}

\begin{listing}[H]
    \begin{minted}{rust}
let (tx, rx) = mpsc::sync_channel(1000);
let rem = Arc::new(AtomicUsize::new(NUM_SPAWN));
rt.block_on(async {
    for _ in 0..NUM_SPAWN {
        let tx = tx.clone();
        let rem = rem.clone();
        tokio::spawn(async move {
            if 1 == rem.fetch_sub(1, Relaxed) {
                tx.send(()); // send signal
            }
        });
    }
    rx.recv(); // block benchmark thread until signal
});
    \end{minted}

    \caption{Атомарная синхронизация в бенчмарках tokio}
    \label{listing:bench:tokio:atom}
\end{listing}

Такой дизайн имеет несколько явных недостатков:

\begin{itemize}
    \item Атомарное чтение и запись из множества исполняемых разными потоками задач скорее позволяет измерять производительность системы памяти физической машины, нежели взаимодействия структур рантайма
    \item Ожидание исполнения в методе \verb|block_on| чревато неточным измерением из-за текущей реализации\footnote{\href{https://github.com/bheisler/criterion.rs/issues/819}{Проблема} измерения производительности асинхронных функций (Дата обращения: 4.1.2025)}
\end{itemize}

Эти методы были улучшены:

\begin{itemize}
    \item Атомарные переменная была заменена иерархией заранее аллоцированных переиспользуемых от итерации к итерации буферами коллекционирующими хендлеры задач
    \item Ожидание хендлеров задач перенесено в отдельную задачу, которая сообщает о завершении обработки с помощью блокирующего канала
\end{itemize}

Накладные расходы вызванные использованием блокирующего канала так же были приняты во внимание, потому, исключительно для проверки, была создана реализация использующая атомарную переменную и спинлок: фиксирующий исполнение и сигнализирующий поток пишет значение в атомарную переменную --- поток бенчмарка ожидает этого в цикле, на листинге \ref{listing:bench:tokiobench:spinlock} приведен псевдокод.

\begin{listing}[H]
    \begin{minted}{rust}
tokio::spawn(async move {
    for handle in handles {
        handle.await; // await tasks in cycle
    }
    task_end.store(true, Release); // send signal
});
while !end.load(Acquire) { // await signal in benchmark thread
    std::hint::spin_loop()
}
    \end{minted}
    \caption{Ожидание исполнения с помощью спинлока}
    \label{listing:bench:tokiobench:spinlock}
\end{listing}

\subsection{Графики}

При создании изображений был сделан упор, там где это уместно, на типе графиков используемых в \verb|TATLIN.BACKUP|.
