% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Реверс инжиниринг tokio}

Шардирование глобальной очереди не позволило достич рсширяемости системы, наблюдаемой при использовании нескольких рантаймов. А значит ограничивать пропускную способность могу другие части системы. Так как архитектура tokio остается не документированной а разарбочики отвечают не охотно будет проведен реверс инжениренг многопоточного рантайма, а именно, тех частей, что используются используются в бенчмарке.

Начнем мы с самого начала --- необходимо понять, как асинхронное замыкание попадает в рантайм, как аллоцируется, когда и кем опрашивается. Отдельно должны быть исследованы алгоритм похищения задач.

\begin{itemize}
    \item Что состовляет т. н. задачу
    \item Спавнинг задач
    \item Что из себя представляет заспавненная задача
    \item Зачем нужна owned queue
    \item Как происходит поллинг задач
    \item Как задача спавнится вторично
    \item Что такое драйвер
    \item Стилинг
\end{itemize}

\subsection{Задача}

Задача представляется структурой RawTask, хранящей указатель на область памяти хранящую различные структуры времени исполнения задачи, среди которых

\begin{itemize}
    \item STATE --- атомарная мутабельная ячейка предоставляющая информацию о состоянии задачи, например:
        \begin{itemize}
            \item RUNNING --- отслеживает, совершает ли переход стейт машина задачи
            \item COMPLETE --- машина состояний достигла конечного состояния
        \end{itemize}
    \item указатель на следующую задачу для поддерки интрузивного связного списка
    \item Индентификатор задачи
    \item \verb|owner_id| --- индентификатор инстанса OwnedTasks
\end{itemize}

Во время исполнение рантайм и пользователь имеют несколько взглядов на задачу с помощью различных структур, среди которых:

\begin{itemize}
    \item Task --- an owned handle to task
    \item Notified --- продукт нотификации задачи
    \item JoinHandle --- handle задачи для пользователя
    \item Waker --- каллбек для последующего шедулинга задачи
\end{itemize}

\subsection{Task spawning}

Спавнинг задачи происходит сделующим образом:

Замыкание,
\begin{itemize}
    \item в заивисимости от размера, боксируется, с сохранением исходного размера для трассировки.
    \item дополняется id за счет FAA на глобальной переменной (потенциальный bottle neck)
    \item обращение к TLS за хендлом на рантайм
    \item аллоцируется TaskRaw из нее получается 3 сущности: Task, Notified, JoinHandle
    \begin{itemize}
        \item Task помещается в OwnedTasks --- шардированную очередь, где шард выбирается на основе id задачи
        \item Notified отправляется на исполнение в рантайм: в глобальную или локальную очередь воркера в зависимости от контекста спавнинга
        \item JoinHandle возвращается пользователю
    \end{itemize}
\end{itemize}

Генерация Id подразумевает установление глобального порядка при взаимодействии с мутабельной ячейкой для всех потоков. Кажется, этого можно избежать при использовании состовного Id, хранящего имеющего индентификатор группы, однако, это увеличит размер задачи. Стоит заметить, в случае нескольких рантаймов так же использовалась единственная мутабельная ячейка --- а прирост производительности наблюдался.

\subsubsection{Исполнение задачи}

Задача, представленная в виде \verb|Notified| рантайму с помщью метода \verb|schedule_task| исполняется попадает в одну из очередей, где ожидает своего исполнения воркером. Воркер, завладев задачей, удостоверивается в безопасности исполнения задачи в данном потоке с помощью метода \verb|assert_owner| инстанса \verb|OwnedTasks|. Затем вызвает метод \verb|run| на типизировнной обертке над RawTask (Harness) и продвигает конечный автомат задачи.

\subsubsection{OwnedTasks}

Взаимодействие с OwnedTasks происходит

\begin{itemize}
    \item при спавнинге задача помещается в шард, выбор которого происходит на основании индентификатора задачи --- срезка значения
    \item при каждом переходе машины состояний происходит проверка значения \verb|owner_id| задачи
    \item при при достижении конечного состояния машины состояний задача удаляется из очереди
\end{itemize}

% Текущий бенчмакр только и делает, что спавнит --- значит, OwnedTasks может ограничивать этот сценарий. Однако, очередь уже шардирована, необходимо только проследить, за спавнингом задач из различных групп в различные шарды. Управлять этим можно за счет Id задачи, здесь нам и пригодятся составные Id!

% Увеличение количества шардов исползуемых при произведении задач позволяет увеличить пропускную способность. (здесь каждая группа использует ровно один шард)

% TODO(picture with composite id usage)

% В текущей реализации количество шардов фиксировано следующим образом:

% const MAX_SHARED_LIST_SIZE: usize = 1 << 16;
% usize::min(MAX_SHARED_LIST_SIZE, num_cores.next_power_of_two() * 4)

% То есть, в случае TATLIN.BACKUP создается 96 * 4 == 386 шардов. На изображении выше приведен случай использования количества шардов равное количеству групп. Таким образом

% \subsection{Resource drivers}

% TODO()
% When configuring a runtime by hand, no resource drivers are enabled by default. In this case, attempting to use networking types or time types will fail. In order to enable these types, the resource drivers must be enabled. This is done with Builder::enable_io and Builder::enable_time. As a shorthand, Builder::enable_all enables both resource drivers.
