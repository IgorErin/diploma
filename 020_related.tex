% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}

Данный раздел содержит обзор решения вопроса с глобальной очередью в рантаймах tokio, языка Go и Kotlin, будет произведен выбор метрик для анализа производительности, приведен частичный обзор алгоритма работы воркера, обоснован выбор инструментов для бенчмаркинга.

\subsection{Многопоточный рантайм tokio}

В этом разделе будут определены основные сущности рантайма, даны интуитивные понятия о их взаимодействии.

\subsubsection{Воркер}

Многопоточный рантайм инициализируется фиксированным числом воркером --- сущностей отвественных за исполнение асинхронных задач. С каждым воркером ассоциирован отдельный системный поток и так называемоя ядро воркера --- структура содержащая состояние воркера. Например, там находится локальная очередь воркера.

\subsubsection{Локальная очередь}

Локальная очередь воркера выступает в качестве кэша его задач, имеет фиксированный размер и предполагает добавление задач в нее исключительно из потока воркера, что владеет этой очередью. Однако, изъятие из нее может быть осуществленно из потоков других воркеров при нехватки оным собственных задач. В случае переполнения локальной очереди часть задач перемещается воркером в глобальную очередь, также известную как inject queue.

\subsubsection{Inject queue}

Глобальная очередь или inject queue представляет собой коллекцию задач ожидающих исполнения.  Наполняется она при спавнинге задачи вне контекста воркера или при переполеннии локальной очереди самих воркеров. Реализована с помощью интрузивного связыного списка, защищенного мьютексом.

\subsubsection{Спавнинг задач}

Когда пользователь хочет запустить задачу, он вызывает метод \verb|tokio::spawn|. Сделать это необходимо в контексте рантайма: внутри метода \verb|block_on| или в промежутке жизнии объекта \verb|EnterGuard|. Контекст реализован с помощью локальной для потока переменной, которая содержит указатели на внутренние структуры рантайма. Позже, задача помещается либо в локальную очередь воркера, если задача спавнилась в потоке воркера, либо в глобальную очередь рантайма.

\newpage

\subsection{Цикл работы воркера}

Воркер в цикле пытается завладеть задачей для исполнения. Если ему это не удается, он пробует украсть задачу у других воркеров. Если и это ему не удается, то tokio паркует поток. На каждой итерации отсчитыается тик --- некая мера времени необходимая для распределения работы, как будет показано далее.

Далее приведен упрощенный алгоритм работы воркера. После чего будут рассмотренны алгоритм взаимодейсвия с очередьми.

\begin{minted}{rust}
fn run() {
    while !is_shutdown() {
        core.tick();
        if let Some(task) = core.next_task() {
            self.run_task(task, core);
            continue;
        }
        if let Some(task) = core.steal_work() {
            self.run_task(task, core);
            continue;
        }
        self.park(core)
    }
}
\end{minted}

\subsubsection{Выбор следущей задачи}

Раз в 61 тик он пытается взять задачу из глобальной очереди. Если ему это не удается, он пытается взять задачу из локальной очереди и, каковым не был бы результат этой попытки, он его вовращает.

Иначе, он пробует взять задачу из локальной очереди. В случае неудачи он пробует взять из глобальной очереди как минимум одну задачу, при этом старается взять сразу несколько, но не все, чтобы оставить другим воркерам. После чего добавляет взятые задачи в собственную локальную очередь, кроме одной, что сразу окажется принятой на исполнение.

Попытка завладеть задачей может быть представлена следующим, снова упрощенным, кодом:

\begin{minted}{rust}
fn next_task(&mut self) -> Option<Notified> {
    if self.tick % self.global_queue_interval == 0 {
        return next_remote_task().or_else(|| self.next_local_task())
    }
    let maybe_task = self.next_local_task();
    if maybe_task.is_some() {
        return maybe_task;
    }
    if inject().is_empty() {
        return None;
    }
    let n = min(
        inject().len() / WORKER_COUNT + 1,
        self.run_queue.remaining_slots(),
        self.run_queue.max_capacity() / 2,
    );
    let mut tasks = inject().pop_n(max(1, n));
    let ret = tasks.next();
    self.run_queue.push_back(tasks);
    return ret
}
\end{minted}

\subsection{Метрики}

tokio-metrics --- проект, предоставющий интерфейс для доступа к значениям метрик, как во время исполнения рантайма, так и после его остановки. Здесь и далее для сбора метрик будет исполользована именно эта библиотека.

\subsubsection{Значения метрик}

Далее будет представлен полный перечень метрик доступных из tokio-metrics. Метрики будут разбиты на группы по аналогии для упрощения текста.

Следующая группа предполагает перечисление в следующем порядке: общее значение, наименьшее для конкретного воркера, наибольшее для конкретного воркера.

\begin{itemize}
    \item Количество парковок потоков воркеров: total\_park\_count, min\_park\_count, max\_park\_count
    \item Это значение представляет собой экспоненциально взвешенную скользящую среднюю продолжительности опросов задач: mean\_poll\_duration, mean\_poll\_duration\_worker\, mean\_poll\_duration\_worker\_max
    \item Сколько раз поток воркера был распаркован, но не совершил никакой работы перед парковкой: total\_noop\_count, max\_noop\_count, min\_noop\_count
    \item Количество задач, которые воркеры похитили, перместив их в свою локальную очередь: total\_steal\_count, max\_steal\_count, min\_steal\_count
    \item Количесво раз воркеры успешно похител задачи: total\_steal\_operations, max\_steal\_operations, min\_steal\_operations
    \item Количество задач отправленных на исполенние из контектса воркера, что должна попасть в одну из локальных очередей: total\_local\_schedule\_count, max\_local\_schedule\_count, min\_local\_schedule\_count
    \item  Сколько раз воркеры переполнили свои очереди: total\_overflow\_count, max\_overflow\_count, min\_overflow\_count
    \item Количество опросов задач среди всех воркеров: total\_polls\_count, max\_polls\_count, min\_polls\_count
    \item Количество времени исполения задач воркерами: total\_busy\_duration, max\_busy\_duration, min\_busy\_duration
    \item Количество задач помещенных в локальные очереди: total\_local\_queue\_depth, max\_local\_queue\_depth, min\_local\_queue\_depth
\end{itemize}

И остальные:

\begin{itemize}
    \item workers\_count --- Количество воркеров исполняющих задачи. Значение специфицируется при инстанциации рантайма

    \item poll\_time\_histogram --- Гистограмма опросов задач, сгруппированная по времени исполнения опросов

    \item num\_remote\_schedules --- Количество задач, отправленных на исполнение из вне. То есть количество задачи заспавненных вне контекста воркера, задач, попавших в глобальную очередь

    \item global\_queue\_depth --- Количество задач, помещенных в глобальную очередь
\end{itemize}

\subsubsection{Выделенные метрики}

Для решения поставленных задач были выделены метрики, отражающие взаимодействие воркеров с очередями задач. То есть, метрики демонстрирущие глубину глобальной очереди (global\_queue\_depth), локальных очередей (total\_local\_queue\_depth), количество переполнений (total\_overflow\_count), количество похищенных задач (total\_steal\_count), количество удаленных спавнов (num\_remote\_schedules).

\subsection{Criterion}

Для измерений времени исполнения и пропускной способности была использована библиотека \verb|criterion|~TODO(). Так как с помощью нее уже реализованы бенчмарки в проекте tokio.

\subsection{Изменения шедулера языка Go}

Как было отмечено ранее, алгоритмы шедулинга в tokio были созданы с оглядкой на реализацию рантайма языка Go. В свою очередь в шедулинг корутин в Kotlin был сделать по мотивам tokio. С тех пор, никаких изменений рантайм Go не претерпел, точно так же, как рантайм языка Kotlin.
