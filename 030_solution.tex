% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Описание решения}

\subsection{Метрики}

Метрики собираемые рантаймом предполагается использовать в двух направлениях:

\begin{itemize}
    \item Семплирование --- наблюдения поведения внутренних структур рантайма в определенный моменты исполнения задач
    \item Тотальная оценка --- анализ количеств тех или иных операций произведенных за весь период исполнения
\end{itemize}

К первому типу можно отнести глубину глобальной или локальных очередей в определенный момент времени. К последнему --- количество переполнений локальных очередей за все время исполнения. Стоит отметить, что количество переполнений без сомнений имеет смысл фиксировать и во время исполнения определенных сценариев, однако, семплирование с легкостью может упустить стремительно меняющиеся значения. Тогда как тотальная сумма не позволяет упускать отдельные операции.

\verb|tokio-metrics|\footnote{\href{https://github.com/tokio-rs/tokio-metrics}{Репозиторий} проекта tokio-metrics (Дата обращения: 4.1.2025)} --- проект, предоставляющий интерфейс для семплирования метрик рантайма. Далее будет представлен полный перечень метрик доступных из \verb|tokio-metrics|. Метрики будут разбиты на группы по аналогии для уменьшения повторений.

Группа предполагает перечисление в следующем порядке: значение представленное в \verb|tokio-metrics| как общее значение для всех воркеров, минимум и максимум среди воркеров, однако, для краткости в тексте будут обозначены только первое.

\begin{itemize}
    \item \verb|total_park_count| --- количество парковок потоков воркеров
    \item \verb|mean_poll_duration| --- это значение представляет собой экспоненциально взвешенную скользящую среднюю продолжительности опросов задач
    \item \verb|total_noop_count| --- сколько раз поток воркера был распаркован, но не совершил никакой работы перед парковкой
    \item \verb|total_steal_count| --- количество задач, которые воркеры похитили, переместив их в свою локальную очередь
    \item \verb|total_steal_operations| --- количество раз воркеры успешно похитили задачи
    \item \verb|total_local_schedule_count| --- количество задач отправленных на исполнение из контекста воркера, что должны попасть в одну из локальных очередей
    \item \verb|total_overflow_count| --- сколько раз воркеры переполнили свои локальные очереди
    \item \verb|total_polls_count| --- количество опросов задач
    \item \verb|total_busy_duration| --- количество времени исполнения воркерами задач
    \item \verb|total_local_queue_depth| --- количество задач помещенных в локальные очереди
\end{itemize}

И остальные:

\begin{itemize}
    \item \verb|workers_count| --- количество воркеров исполняющих задачи. Значение специфицируется при инстанциации рантайма

    \item \verb|poll_time_histogram| --- гистограмма опросов задач, сгруппированная по времени исполнения опросов

    \item \verb|num_remote_schedules| --- количество задач, отправленных на исполнение из вне. То есть количество задач, попавших в глобальную очередь при создании

    \item \verb|global_queue_depth| --- количество задач, помещенных в глобальную очередь
\end{itemize}

Для решения поставленных задач были выделены метрики, отражающие взаимодействие воркеров с очередями. То есть, метрики, демонстрирующие глубину глобальной очереди (\verb|global_queue_depth|), локальных очередей (\verb|total_local_queue_depth|), количество переполнений (\verb|total_overflow_count|), количество похищений (\verb|total_steal_operations|), количество удаленных спавнов (\verb|num_remote_schedules|).

Стоит отметить возможность сбора метрик для отдельной задачи, применение чему не было найдено.

\subsection{Система бенчмарков}

В качестве системы бенчмарков был создан проект \verb|tokiobench|\footnote{\href{https://github.com/IgorErin/tokiobench}{Репозиторий} проект tokiobench (Дата обращения: 4.1.2025)}, где предполагалось реализовать автоматизированные сценарии бенчмарков, сбор метрик и визуализацию полученных данных в виде графиков.

\subsection{Поиск сценариев}

В условиях недоступности кода \verb|TATLIN.BACKUP| поиск интересных с точки зрения производительности сценариев по взаимодействию с глобальной очередью был начат с репозиторий проекта \verb|tokio|.

Среди приведенных там сценариев был выделен один, представленный на листинге \ref{listing:bench:tokio:remote}.

\begin{listing}[H]
    \begin{minted}{rust}
for _ in 0..NUM_SPAWN {
    handles.push(rt.spawn(async {}));
}
rt.block_on(async {
    for handle in handles.drain(..) {
        handle.await.unwrap();
    }
});
    \end{minted}

    \caption{Tokio context spawning benchmark}
    \label{listing:bench:tokio:remote}
\end{listing}

А именно, задачи, в виде пустых асинхронных замыканий, спавнятся в главном потоке, их хендлеры коллекционируются, после чего рантайм поочередно ожидает исполнения задач используя метод \verb|block_on|.

В ходе общения с инженерами из \verb|TATLIN.BACKUP| был выделен сценарий их приложения: там присутствуют задачи, далее именуемые спавнерами, которые создают множество простых задач, далее именуемых листовыми задачами. Причем количество спавнеров и листовых задач варьируется.

\subsection{Проблема синхронизации}

Измерение производительности в данном случае предполагает измерение пропускной способности рантайма, что подразумевает измерение времени необходимое этому рантайму для исполнения фиксированного количества задач. Однако, для этого необходимо определить, когда все задачи были исполнены. Публичный интерфейс \verb|tokio| не позволяет получить информацию об этом, так как число необходимых к исполнению задач известно лишь пользователю. То есть нужно иметь какую-то синхронизацию, блокировать поток бенчмарка в ожидании конца обработки специфицированных рантайму задач. В бенчмарках \verb|tokio| делают это следующими способами:

\begin{itemize}
    \item Коллекционирует хендлеры, как представлено на листинге \ref{listing:bench:tokio:remote} и последовательно ожидают их в цикле с помощью метода \verb|block_on|
    \item Создают атомарную переменную с значением равным количеству задач и в каждой листовой задаче уменьшают ее значение на единицу. Задача, которая получила ноль в результате операции атомарного декремента, посылает сигнал с помощью блокирующего канала в главный поток, тем самым разблокирует его, как представлено на листинге \ref{listing:bench:tokio:atom}
\end{itemize}

\begin{listing}[H]
    \begin{minted}{rust}
let (tx, rx) = mpsc::sync_channel(1000);
let rem = Arc::new(AtomicUsize::new(NUM_SPAWN));

rt.block_on(async {
    for _ in 0..NUM_SPAWN {
        let tx = tx.clone();
        let rem = rem.clone();
        tokio::spawn(async move {
            if 1 == rem.fetch_sub(1, Relaxed) {
                tx.send(()).unwrap();
            }
        });
    }
    rx.recv().unwrap();
});
    \end{minted}

    \caption{Атомарная синхронизация в бенчмарках tokio}
    \label{listing:bench:tokio:atom}
\end{listing}

Такой дизайн имеет несколько явных недостатков:

\begin{itemize}
    \item Атомарное чтение и запись из множества исполняемых разными потоками задач скорее позволяет измерять производительность системы памяти физической машины, нежели взаимодействия структур рантайма
    \item Ожидание исполнения в методе \verb|block_on| чревато неточным измерением из-за текущей реализации\footnote{\href{https://github.com/bheisler/criterion.rs/issues/819}{Проблема} измерения производительности асинхронных функций (Дата обращения: 4.1.2025)}
\end{itemize}

Эти методы были улучшены:

\begin{itemize}
    \item Атомарные переменная была заменена иерархией заранее аллоцированных переиспользуемых от итерации к итерации буферами коллекционирующими хендлеры задач
    \item Ожидание хендлеров задач перенесено в отдельную задачу, которая сообщает о завершении обработки с помощью блокирующего канала
\end{itemize}
