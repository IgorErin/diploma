% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Проектирование решения}

После полученных результатов команда \verb|TATLIN.BACKUP| провела эксперименты, где так же стало очевидно преимущество использования нескольких рантаймов с точки зрения пропускной способности.

Однако, неясным осталась надежность такой системы: разработчики tokio не дают никаких гарантий при исполоьзовании нескольких рантаймов, а наоборот утверждают, что при некотором обращении с такой конструкцией могут быть наблюдаемы падения производительности или достижимо неопределенное поведение.

\verb|TATLIN.BACKUP| позиционирует себя как высоконадежное производительное решение, а потому использовать в нем конструкцию без гарантий не возможно.

\subsection{Шардирование глобальной очереди}

Если дублировать весь рантайм нельзя, вероятно, уменьшить ограничение накладовое глобальной очередью получится при использовании нескольких глобальных очередей в одном рантайме, как представленно на изображении далее.

% ТУДУ ПИК

Здесь и далее под рабочей группой будет пониматься глобальная очередь с фиксированным количеством воркеров.

Это было реализовано с следующими измененями в интерефейсе tokio:

\begin{itemize}

\item При создании рантайма пользователь специфицирует количество количество воркеров (\verb|worker_threads|) и количество очередей (\verb|worker_groups|). В результате рантайм инстанциируется с \verb|worker_threads| * \verb|worker_groups| системными потоками для исполнения асинхронных замыканий.
\item При создании задачи c помощью метода \verb|tokio::spawn| выбор рабочей группы осуществляется с помощью локального для потока рандома~\cite{TODO}.
\end{itemize}

Каждая группа изолирована от остальных, то есть воркеры не могут похищать задачи из других глобальных очередей, кроме своей. Это вынуждает их быть запаркованными при нехватке задач в собственной группе и не конфликтовать с другими воркерами.

\subsection{Индентификатор задач}

При создании задач для нее генерируется индентификатор на одной статической ячейке памяти, переменная разделяемая между всеми попытками создать задачу в процессе. То есть при создании каждой задачи, пусть даже в различных потоках, сразуже устанавливается глобальный порядок на одной ячейке памяти для поддержания уникальности индентификаторов.

Этого можно избежать если, индентификатор будет состоять из двух частей как представлено на листинге~\ref{TODO} --- в таком случае можно инстанциировать несколько производителей различных индентификаторов.

\begin{listing}[H]
    \begin{minted}{rust}
struct Id {
    head: u64,
    tail: u64,
}
    \end{minted}

    \caption{Асинхронное замыкание}
    \label{listing:async_closure}
\end{listing}

А именно: на статической атомарной перменной будет производиться генерации первой части индентификатора задачи, так называемого индентификатора производителя индентификаторов задач, представленного на листинге~\ref{TODO}

\begin{listing}[H]
    \begin{minted}{rust}
struct IdProvider {
    head: u64,
    tail_counter: AtomicU64,
}
    \end{minted}

    \caption{Асинхронное замыкание}
    \label{listing:async_closure}
\end{listing}

каждый из которых будет иметь собственную атомарную ячейку памяти для генерации индентификаторов задач.

\subsection{Выбор шарда в OwnedTasks}

При создании задачи ее необходимо зарегистрировать в OwnedTasks, путем выбора шарда и помещению в него указателя Task. Выбор шарда ранее происходила с помощью индентификатора задачи --- путем его преобразвания в \verb|usize|. То есть использование шардов происходило последовательно.

Однако, при наличии составного индентификатора повышается возможность конфликта при выборе шарда, что значительно снижает производительсноть, поэтому в данный момент применение составному индентификатору не найдено.
